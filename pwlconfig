#! /bin/bash
#
###
# Usage: pwlconfig [project_name] [Options]
#
#    Configure and maintain Pee Wee Linux Projects for
#    embedded targets. Use from command line or interactively.
#
# Options:
#  -B, --boot         run lilo on project device for standalone booting
#  -D, --dual-boot    run lilo on this drive to boot to project device
#  -E, --erase        erase and format project device
#  -e, --extract [source_dir]
#                     extract files to source dir from project configuration
#  -l, --load [source_dir [ device_mount_point ]]
#                     load extracted project source image to device
#  -n, --new new_project_name
#                     create a new Pee Wee Linux project
#      --help         dislay this help and exit
#      --version      output version information and exit
#
# Where:
#    project_name     defaults to last project used
#    new_project_name a new name for a project
#    source_dir...    all other parameters default to project defaults
#
#  All other sub-menu operations are available from command line using
#  other PWL scripts. Use --help for each tool in the scripts directory.
###
#
# pwlconfig
#
#    Many (ok, very many) Features copied from Menuconfig script
#    Requires lxdialog from /usr/src/linux/scripts/lxdialog
#
#    Created by Ralph Stickley rstickley@datalux.com
#
#    Built for Pee Wee Linux created by Adi Linden adi@adis.on.ca
#
# Notes:
#
#   pwlconfig is designed entirely around the lxdialog utility as found in 
#   /usr/src/linux/scripts/lxdialog.  All user interface dialogs are displayed
#   and all user keystrokes are handled by lxdialog. 
#
#   The major function groups in this program are:
#      show_xxxx   - wrapper functions that call lxdialog
#      build_xxxx  - functions that create lists for the dialog box
#      extract_xxx - functions that extract files from project list files
#      device_xxx  - functions which deal with the disk on chip device
#      menu_xxx    - handle menu input to execute commands
#
#   Directory Structure used:
#      Package  - location of 'tarballs' optimized for embedded systems
#      scripts  - utility functions
#      projects - location of user configurations and filesystems
#      mnt      - normally where target device is mounted
#
#   Project Files:
#      project.conf - Main configuration file - any tarball listed here
#                     will be extracted into the users filesystem
#      xxx.list     - lists the files to be extracted from each tarball
#      .xxx.list    - configuration in progress file
#
# History
#    -v0.90 - Added Dual boot capability, fixed erase, use pwl usage, use
#             project defaults where applicatable
#    -v0.86 - maintain hidden .extract.log and .lilo.res files for debugging
#             include device mount point (from project defaults) on Erase
#    -v0.85 - fixed command line extraction process
#    -v0.84 - more extraction of code
#    -v0.82 - move Update to main menu, cleanup cleanups, proper lilo options
#           - re-added feature to check custom source files by date
#    -v0.8  - massive changes using multiple smaller scripts
#    -v0.7a - speed ups and updating fixed, rm option for debug
#    -v0.7b - use mkBootDevice script
#    -v0.7c - split out defaults, custom and project functions into
#             little scripts
#    -v0.7d - added smart save, fix Update cmd for tar files
#
#    v0.7 - bug fixes, added Update project function, split with pwl_custom
#    v0.6 - bug fix to support 'nearly' matching filenames, added debug utilities
#           re-worked command line parameters and added usage statement
#    v0.5 - package selection from subdirectories; cleanup function names
#    v0.4 - more major bug fixes, added file sizes to help figure system size
#    v0.3 - major bug fixes, require root login to extract devices and DOC erase
#    v0.2 - Added multiple configurations, custom files handling
#    v0.1 - released not tested
#
#=============================================================================
#
# Make sure we're really running bash.
#
[ -z "$BASH" ] && { echo "`basename $0` requires bash" 1>&2; exit 1; }
#
#  constants for this shell script
#
#
export usrMode="I"
#
# include utility functions
#
. ./scripts/pwl_functions
#
PWL_VER=${PWL_REL_VER}".1"
#
#=============================================================================
#=============================================================================
#
#  show_xxx  - uses lxdialog to show menu items
#              returns the 'tag' the selected item on error stream
#              returns the keyId of the key pressed as function status
#              keyIds are:
#                  0 - user pressed ENTER key with "select" highlighted
#                  1 - user pressed ENTER key with "Exit" highlighted
#                  2 - user pressed '?' or ENTER key with "Help" highlighted
#                       (also returns text of selected item on error stream)
#                  3 - user pressed 'Y' or 'y'
#                  4 - user pressed 'N' or 'n'
#                  5 - user pressed 'M' or 'm'
#                  6 - user pressed ' ' (ignores which button is highlighted)
#                255 - user pressed 'Esc'
#
#  show_main ( main_menu_list )
#
function show_main()
{
   if [ -z "$mainDefault" ] ; then
      mainDefault=config
   fi
   echo -n $DIALOG --title "'Main Menu'"       \
                   --backtitle "'$backtitle'"  \
                   --menu                      \
"'Pee Wee Linux System Menu                   Project: $CFG_BASE'" \
         $ROWS $COLS $((ROWS-8))                                   \
         "'$mainDefault' " > .dialog

   cat $1 >> .dialog
   #
   # execute and return results
   #
   . ./.dialog
}

#=============================================================================
#
# build_main( main_menu_list )
#     creates given file with contents of main menu options
#
function build_main()
{
   $decho "start build_main"
   if [ "$deviceName" = "" ] ; then
      echo Internal error - set device
      exit 0
   fi

   echo -n "'PkgConfig' 'Configure Project File System -->'             \
            'Update'    'Update \"$CFG_BASE\" from File System --> '    \
            'Extract'   'Extract File System for Project'               \
            'skip'      '----'                                          \
            'Erase'     'Erase $deviceName at $deviceLoc$devicePartition' \
            'Load'      'Load File System onto $deviceName'             \
            'Dual'      'Allow this system to dual-boot $deviceName'    \
            'Lilo'      'Install LInux LOader (LILO) to $deviceName'    \
            'skip'      '----'                                          \
            'PrjManage' 'Manage Projects -->'                           \
            'Save'      'Save Project'                                 "> $1
   #
   $decho "end build_main"
}

#=============================================================================
#
# extract_custom( mountPoint ) - copy custom files to mount point
#
function extract_custom ()
{
   $decho "start extract_custom"
   echo ""
   fileCount=0

   if [ -f "$PWL_PRJ"/"$CUSTOM_LST" ] ; then
      #
      echo "Copying Custom files as specified in $PWL_PRJ/$CUSTOM_LST "
      echo ""
      #
      $PWL_CUSTOM --extract $1 2> .return
      read fileCount < .return
      $RM -rf .return

   fi
   if [ "$fileCount" = "0" ] ; then
      echo "No Custom Files Copied"

   else
      echo ""
      echo "Custom File Copy done - $fileCount files copied"
      echo ""
   fi
   echo ""
   $decho "end extract-custom"
   $RM .return
}

#
# extract_packages ( mountPoint )
#    Extracts all files specified in a project configuration
#    Every package file listed in CFG_FILE is extracted based on the
#    files listed in that package's <pkg_fn>.list included in the project
#
function extract_packages()
{
   $decho "start extract_packages"
   echo -n Extracting files from:
   $MOVE_TO_COL
   echo as specified in:
   echo ""
   #
   loc=$PWD
   ln=1
   #
   if [ ! -f $CFG_FILE ] ; then
      return
   fi
   for nfile_lst in `cat $CFG_FILE`; do
       #
       # each list file needs it's tar ball untarred at mount point
       #
       pkgDir=`dirname $nfile_lst`
       lst_file=`basename "$nfile_lst"`
       tar_file=`basename $nfile_lst .list`".tar"
       #
       if [ ! -f "$pkgDir"/"$tar_file" ] ; then
          echo $CFG_FILE Error: $pkgDir\$tar_file not found \(line "$ln"\)

       elif [ ! -f "$PWL_PRJ"/"$lst_file" ] ; then  # internal error ??
             echo Configuration list file $PWL_PRJ/$lst_file not found

       else
          #
          #  nice printout of whats happening
          cd $1
          echo -n $tar_file
          $MOVE_TO_COL
          echo "$CFG_BASE"/"$lst_file"
          #
          # seperate directories and file  (dirs are names that end in '/')
          #  'cause extracting a directory extracts all files found in that directory
          #   *but* not extracting an empty directory doesn't create that directory
          #
          grep -v "\/$" "$loc"/"$PWL_PRJ"/"$lst_file"  > "$loc"/.cfg_files
          grep    "\/$" "$loc"/"$PWL_PRJ"/"$lst_file" | sort -r > "$loc"/.cfg_dirs
          #
          # add back only directories specified that are empty
          #
          for includeDir in `cat $loc/.cfg_dirs` ;
          do
              # if a required directory is not already in the list of
              #  files to extract, add it to the list of files to extract
              #  to allow tar to create an empty directory
              #
              if ! grep -q $includeDir $loc/.cfg_files ; then
                 echo $includeDir >> $loc/.cfg_files
              fi
          done
          #
          # do the actual extraction (-p keeps permmissions)
          # -k does not write over existing files
          # ( Note: tar still gives errors on empty directories that
          #         contain empty directories..you just can't win :()
          #
          $TAR -xpkf "$loc"/"$pkgDir"/"$tar_file" -T "$loc"/.cfg_files 2>&1

          cd $loc
       fi
       #
       ln=`expr $ln + 1`    # increment line counter for debugging
   done
   cd $loc
   #
   echo ""
   echo " Total Size of Package Files extracted: `du $1 -bsh` "
   echo ""
   #
   $RM .tmp .cfg_files .cfg_dirs
   $decho "end extract_packages"
}

#
# extract_project( [mntPt ] )
#     Prompts for the extraction point and extracts files as defined by
#     the project configuration - packages and custom files.
#
function extract_project()
{
   $decho "start extract_project"
   #
   # save changes if any
   #
   confirm_save
   #
   if [ "$1" != "" ] ; then
      mntName="$1"

   else
      get_string "Build File System for project $CFG_BASE" \
                 "Enter path and name of mount point:" \
                 "mntName" "$PWL_PRJ"/"$prjMnt"
      if [ $? != "0" -o "$mntName" = "" ] ; then
         return
      fi
   fi
   #
   if [ -d "$mntName" ] ; then
      show_confirm "Mount Point Exists" "Remove File System created at: $mntName ?"
      if [ $? != "0" ] ; then
         return             # let user specify another mount point
      fi
   fi
   #
   # extract packages and custom files
   #
   rm -rf $mntName
   mkdir "$mntName"                                   > .extract.log
   #
   if [ ! "$?" = "0" ] ; then
      show_message "Mount Point Not Created" "Error Creating Directory"
      return 0
   fi
   #
   extract_packages "$mntName"                        >> .extract.log 2>&1
   extract_custom   "$mntName"                        >> .extract.log 2>&1
   #
   echo ""                                            >> .extract.log
   echo "Total System File Size: `du $mntName -bsh` " >> .extract.log
   echo ""                                            >> .extract.log
   #
   show_results .extract.log "Extracted File System"
   #
   $RM .extract.log
   $decho "end extract_project"
}

#=============================================================================
#
# device_erase - erase device mounted (or re-mount) the device
#
function device_erase()
{
   $decho "start device_erase"
   #
   # get user defined mount point ??
   #
   get_string "Erase Device Contents" \
              "Enter path and name of device mount point:"\
              "destMntName" "$deviceMnt"
   if [ $? != "0" ] ; then
      return
   fi
   if [ ! -d "$destMntName" ] ; then
      show_message "Mount point not found" \
         "Mount point: $destMntName was not found"
      return
   fi
   #
   # confirm erase
   #
   show_confirm "Confirm Erase Device" \
     "Are you sure you want to erase $deviceType device at $deviceLoc$devicePartition ?"
   if [ $? = "0" ] ; then
      #
      # Erase it - note: if device is not mountable as is, we have to
      #            erase it first before we mount it (-e then -m).
      #
      $DEV_MGR $deviceType --device $deviceLoc --dev-id $devicePartition --mount $destMntName -e -m |tee .erase.log
      #
      # tell them what happened
      #
      show_results .erase.log "Erase Device Results"
      #
      $RM .erase.log
   fi
   #
   $decho "end device_erase"
}

#
# device_dual_boot()
#     Copies existing /etc/lilo.conf file and appends section to install
#     the project device as a bootable option at power up.
#
function device_dual_boot()
{
   $decho "start device_dual_boot"
   #
   # get system boot device
   #
   sysBootDevice=`mount | head -1`
   sysBootDevice=${sysBootDevice%%[0-9]*}
   #
   show_confirm "Update LILO on this machine" \
"Boot device for this machine is: $sysBootDevice.  You are 
about to Modify the Master Boot Record for this device. 
Make sure you have a boot disk available!" 10
   if [ $? != "0" ] ; then
      return
   fi
   if [ "$destMntName" = "" ] ; then
      destMntName="$deviceMnt"
   fi
   #
   get_string "Allow LILO to access Device" \
              "Enter path and name of device mount point:"\
              "destMntName" $destMntName
   if [ $? != "0" ] ; then
      return
   fi
   if [ ! -d "$destMntName" ] ; then
      show_message "Mount point not found" \
         "Mount point: $destMntName was not found"
      return
   fi
   #
   # Lilo it - note root device is the same as the device location when
   #           we dual boot - ignore bootDevice
   #
   $DEV_MGR  $deviceType --mbr-device $sysBootDevice --mount $destMntName \
             --label $bootLabel --kernel $bootKernel --dev-id $devicePartition \
             --device $deviceLoc --root-dev ${deviceLoc}${devicePartition} \
             -m --dual-boot 2>&1 |tee .dlilo.log
   #
   show_results .dlilo.log "LILO on $deviceName"
   #
   $RM .dlilo.log
   $decho "end device_dual_boot"
}

#
# device_lilo()
#        Builds a lilo.conf.DEVICE file to install the Linux Loader onto
#        the device and all it to boot as a master boot device.
#
function device_lilo()
{
   $decho "start device_lilo"
   #
   # get user defined mount point
   #
   if [ "$destMntName" = "" ] ; then
     destMntName="$deviceMnt"
   fi
   # 
   get_string "Install LILO on Device" \
              "Enter path and name of device mount point:"\
              "destMntName" $destMntName
   if [ $? != "0" ] ; then
      return
   fi
   if [ ! -d "$destMntName" ] ; then
      show_message "Mount point not found" \
         "Mount point: $destMntName was not found"
      return
   fi
   #
   # Tell user about our defaults
   #
   show_message "Note on Lilo Configuration" \
"Configuration parameters for LILO operation are stored in \
 \"lilo.conf.$deviceType\". Please verify these before attempting to boot this device!"
   #
   # Lilo it
   #
   $DEV_MGR  $deviceType --mount $destMntName \
             --label $bootLabel --kernel $bootKernel \
             --dev-id $devicePartition --mbr-device $bootDevice \
             --device $deviceLoc --root-dev $bootDevice  -mb 2>&1 |tee .lilo.log
   #
   show_results .lilo.log "LILO on $deviceName"
   #
   $RM .lilo.log
   $decho "end device_lilo"
}

#
# device_load_fs( [ sourceMnt, deviceMntName ])
#    Load file system created for this project onto the current device
#    prompts for source and destination then show results
#
function device_load_fs ()
{
   $decho "start device_load_fs"
   #
   # Get location of existing file system (show default)
   #
   if [ "$1" != "" ] ; then
      srcMntName="$1"
   else
      get_string "Load File System: Source" \
                 "Enter path and name of file system :" \
                 "srcMntName" "$PWL_PRJ"/"$prjMnt"
      if [ $? != "0" ] ; then
         return
      fi
   fi
   if [ -z "$srcMntName" ] || [ ! -d "$srcMntName" ] ; then
      show_message "Existing File System Not Found" \
             "Could Not find $srcMntName. Make sure you have selected 'Extract File System for Project' first"
      return
   fi
   #
   # get user defined mount point
   #
   if [ "$1" != "" -a "$2" != "" ] ; then
      $decho "using destination parameter $2"
      destMntName="$2"
   else
      if [ "$destMntName" = "" ] ; then
         destMntName="$deviceMnt"
      fi
      get_string "Load File System: Destination" \
                 "Enter path and name of device mount point:"\
                 "destMntName" $destMntName
      if [ $? != "0" ] ; then
         return
      fi
   fi
   #
   if [ -z "$destMntName" ] ; then
      return
   fi
   #
   # execute command to load the file system
   #
   $DEV_MGR  $deviceType --source $srcMntName --mount $destMntName \
             --label $bootLabel --kernel $bootKernel --dev-id $devicePartition \
             --device $deviceLoc --root-dev $bootDevice  -mc |tee .load.log
   #
   # Note: tee in above command kills status
   #
   echo "" >> .load.log
   echo " Total Size of new file system: `du $destMntName -bsh` " >> .load.log
   #
   # view results
   #
   show_results .load.log "Load File System - Results"
   #
   $RM  .load.log
   $decho "end device_fs_load"
}

#=============================================================================
#
# menu_main()
#    pwlconfig main menu, interactive operation is here, by golly
#
function menu_main()
{
   $decho "start menu_main"
   #
   mainDone=0
   build_main .main.lst
   #
   while [ "$mainDone" = "0" ]; do

      show_main .main.lst 2> .result

      retVal=$?
      read selection <.result
      mainDefault=$selection

      if [ "$retVal" = "1" ]  ; then    # exit -
         mainDone=1                     #     don't 'escape' from main, lets
                                        #     you lay on the esc key and not
                                        #     get kicked out :-)
      elif [ "$retVal" = "2" ] ; then
         show_help menu_main            # help
      else
         case "$selection" in
             "PkgConfig")
                     $PWL_PKGCONF
             ;;
             "Extract")
                     extract_project
             ;;

             "Update")               # compare mounted filesystem with
                                     # files at mount point
                     $PWL_UPDATE
             ;;
             "Erase")
                     device_erase
             ;;
             "Load")
                     device_load_fs
             ;;
             "Lilo")
                     device_lilo
             ;;
             "Dual")
                     device_dual_boot
             ;;
             "Save")
                     confirm_save
             ;;
             "PrjManage")
                     confirm_save
                     $PWL_PROJECTS
                     if [ $? = "1" ] ; then # no project selected
                        mainDone=1;
                     else                   # reset defaults
                        pwl_init_project
                        default_define
                        build_main .main.lst
                     fi
             ;;
        esac
     fi
     #
   done
   # cleanup
   $RM  .select.lst .result .dialog .main.lst
   $decho "end menu_main"
}

#=============================================================================
#
# cleanup
#
function cleanup() 
{
   $decho "start cleanup"
   $RM -f .result .dialog
   $decho "end cleanup"
   if [ "$1" != "" ] ; then  # quit program
      exit $1
   fi
}

#=============================================================================
#
#  main_init() setup project environment - call whenever project changes
#              (multiple calls are ok :-)
#
function main_init()
{
   $decho "start main_init"
   #
   export backtitle="Pee Wee Linux System Configuration - Version $PWL_VER"
   progInfo=$backtitle
   #
   # check for initial setup
   #
   pwl_init_project default
   if [ "$?" = "1" ] ; then
      cleanup  #not root user
   fi
   #
   export CFG_BASE=none
   $PWL_PROJECTS --init
   status=$?
   if [ "$status" = "1" ] ; then
      # no valid project entered
      cleanup 1
   fi
   #
   # set global project variables
   #
   pwl_init_project
   default_define
   if [ "$?" = "1" ] ; then # no default files found, prompt & create
      $PRJ_DEFAULTS --reset FLASH
      if [ "$?" = "1" ] ; then
         cleanup 1
      fi
      default_define   # now load default variables
   fi
   #
   # verify custom files are up to date with source files
   #
   $PWL_CUSTOM --update
   #
   $decho "end main_init"
}

#
#  cmd_parse_commands - parses command line parameters
#
#      if project name is specified, it must be first parameter
#      on the command line
#
function cmd_parse_commands ()
{
   $decho "start cmd_parse_commands"
   #
   # parse commands
   #
   while [ ! "$1" = "" ] ;
   do
      $decho "Parsing Cmd: $1"
      cmd=$1
      shift
      case "$cmd" in
      "B"|"--boot")                # run lilo on project device
          main_init
          usrMode="C"
          #
          device_lilo
          exit 0
          ;;
      "D"|"--dual-boot")           # run lilo on this drive for dual boot
          main_init
          usrMode="C"
          #
          device_dual_boot
          exit 0
          ;;
      "E"|"--erase")                # erase project device
          main_init
          usrMode="C"
          #
          device_erase
          exit 0
          ;;

      "-e"|"--extract")            # extract project files (allow copy parm)
          main_init
          usrMode="C"
          #
          mntPt=$PWL_PRJ/$prjMnt
          if [ ! "$1" = "-c" -a ! -z "$1" ] ; then     #optional mount point specified
             mntPt=$1
             shift
          fi
          extract_project "$mntPt"
          #
          exit 0
          ;;
      "-l"|"--load")               # copy files from project to mount point
          main_init
          usrMode="C"
          #
          deviceMntName="$deviceMnt"               # default destination
          sourceMnt="$PWL_PRJ/$prjMnt"
          if [ ! -z "$1" ] ; then
              sourceMNT=$1              # source mount specified
              shift
              if [ ! -z "$2" ] ; then
                 deviceMntName=$2           # destination mount specified
                 shift
              fi
          fi
          device_load_fs $sourceMnt $deviceMntName
          exit 0                   # no more parameters allowed
          ;;

      "-d")                        # undocumented feature!;-)
          if [ $debugMode = "0" ] ; then
             debug_mode  1
          else
             debug_mode 0
          fi
          ;;

      "-n"|"--new")                # not a menu item, but makes sense to add here ?
          usrMode="C"
          $PWL_PROJECTS --init $2
          exit 0
          ;;

      "-h"|"--help")
          usage
          exit 0
          ;;

      "-v"|"--version")
          echo "`basename $0` (Pee Wee Linux Configuration utility) Version $PWL_VER"
          exit 0
          ;;

      *)
          usage "$cmd:  not a valid project name or pwlconfig option"
          exit 0
          ;;

      esac
   done
   #
   $decho "end cmd_parse_commands"
}

#=============================================================================
#
# void pwlconfig_main( arg1 arg2 arg3 )
#
#
function pwlconfig_main()
{
   $decho "start pwlconfig_main"
   #
   # error handler
   #
   trap "cleanup ; exit 1" 1 2 15
   #
   #  Handle command line parameters if they exist
   #
   cmd_parse_commands $*
   #
   # select project to start with (last used, first found or create new)
   # - sets all global project variables
   #
   main_init
   #
   # operate the menus
   #
   menu_main
   #
   # Ask to Save configuration
   #
   confirm_save
   #
   cleanup
   $decho "end pwlconfig_main"
}

# start here
   debug_mode 0           # set to 1 to enable debug macros

   $decho "START $0 $*"

   pwlconfig_main $*

   $decho "END $0"

   exit 0
#
# end.
#
